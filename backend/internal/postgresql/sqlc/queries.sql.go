// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createComment = `-- name: CreateComment :one
INSERT INTO Comments (user_id, post_id, description) VALUES ($1, $2, $3) RETURNING comment_id, post_id, user_id, description, created_at, updated_at
`

type CreateCommentParams struct {
	UserID      int64  `json:"user_id"`
	PostID      int64  `json:"post_id"`
	Description string `json:"description"`
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment, arg.UserID, arg.PostID, arg.Description)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.PostID,
		&i.UserID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO Posts (topic_id, user_id, title, description) VALUES ($1, $2, $3, $4) RETURNING post_id, topic_id, user_id, title, description, created_at, updated_at
`

type CreatePostParams struct {
	TopicID     int64  `json:"topic_id"`
	UserID      int64  `json:"user_id"`
	Title       string `json:"title"`
	Description string `json:"description"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost,
		arg.TopicID,
		arg.UserID,
		arg.Title,
		arg.Description,
	)
	var i Post
	err := row.Scan(
		&i.PostID,
		&i.TopicID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTopic = `-- name: CreateTopic :one
INSERT INTO Topics (user_id, title) VALUES ($1, $2) RETURNING topic_id, user_id, title, created_at
`

type CreateTopicParams struct {
	UserID int64  `json:"user_id"`
	Title  string `json:"title"`
}

func (q *Queries) CreateTopic(ctx context.Context, arg CreateTopicParams) (Topic, error) {
	row := q.db.QueryRow(ctx, createTopic, arg.UserID, arg.Title)
	var i Topic
	err := row.Scan(
		&i.TopicID,
		&i.UserID,
		&i.Title,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO Users (name) VALUES ($1) RETURNING user_id, name
`

func (q *Queries) CreateUser(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, createUser, name)
	var i User
	err := row.Scan(&i.UserID, &i.Name)
	return i, err
}

const deleteComment = `-- name: DeleteComment :execrows
DELETE FROM Comments WHERE comment_id = $1
`

func (q *Queries) DeleteComment(ctx context.Context, commentID int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteComment, commentID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deletePost = `-- name: DeletePost :execrows
DELETE FROM Posts WHERE post_id = $1
`

func (q *Queries) DeletePost(ctx context.Context, postID int64) (int64, error) {
	result, err := q.db.Exec(ctx, deletePost, postID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteTopic = `-- name: DeleteTopic :execrows
DELETE FROM Topics WHERE topic_id = $1
`

func (q *Queries) DeleteTopic(ctx context.Context, topicID int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteTopic, topicID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findCommentsByPost = `-- name: FindCommentsByPost :many
SELECT c.comment_id, c.user_id, u.name as username, c.post_id, c.description, c.created_at, c.updated_at
FROM Comments c JOIN Users u ON u.user_id = c.user_id WHERE c.post_id = $1 ORDER BY c.updated_at DESC
`

type FindCommentsByPostRow struct {
	CommentID   int64              `json:"comment_id"`
	UserID      int64              `json:"user_id"`
	Username    string             `json:"username"`
	PostID      int64              `json:"post_id"`
	Description string             `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

// Comments Queries
func (q *Queries) FindCommentsByPost(ctx context.Context, postID int64) ([]FindCommentsByPostRow, error) {
	rows, err := q.db.Query(ctx, findCommentsByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindCommentsByPostRow
	for rows.Next() {
		var i FindCommentsByPostRow
		if err := rows.Scan(
			&i.CommentID,
			&i.UserID,
			&i.Username,
			&i.PostID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPostByID = `-- name: FindPostByID :one
SELECT p.post_id, p.topic_id, p.user_id, u.name AS username, p.title, p.description, p.created_at, p.updated_at
FROM Posts p JOIN Users u ON u.user_id = p.user_id WHERE post_id = $1 AND topic_id = $2
`

type FindPostByIDParams struct {
	PostID  int64 `json:"post_id"`
	TopicID int64 `json:"topic_id"`
}

type FindPostByIDRow struct {
	PostID      int64              `json:"post_id"`
	TopicID     int64              `json:"topic_id"`
	UserID      int64              `json:"user_id"`
	Username    string             `json:"username"`
	Title       string             `json:"title"`
	Description string             `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) FindPostByID(ctx context.Context, arg FindPostByIDParams) (FindPostByIDRow, error) {
	row := q.db.QueryRow(ctx, findPostByID, arg.PostID, arg.TopicID)
	var i FindPostByIDRow
	err := row.Scan(
		&i.PostID,
		&i.TopicID,
		&i.UserID,
		&i.Username,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findPostsByTopic = `-- name: FindPostsByTopic :many
SELECT p.post_id, p.topic_id, p.user_id, u.name AS username, p.title, p.description, p.created_at, p.updated_at
FROM Posts p JOIN Users u ON u.user_id = p.user_id WHERE p.topic_id = $1 ORDER BY p.updated_at DESC
`

type FindPostsByTopicRow struct {
	PostID      int64              `json:"post_id"`
	TopicID     int64              `json:"topic_id"`
	UserID      int64              `json:"user_id"`
	Username    string             `json:"username"`
	Title       string             `json:"title"`
	Description string             `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

// Posts Queries
func (q *Queries) FindPostsByTopic(ctx context.Context, topicID int64) ([]FindPostsByTopicRow, error) {
	rows, err := q.db.Query(ctx, findPostsByTopic, topicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindPostsByTopicRow
	for rows.Next() {
		var i FindPostsByTopicRow
		if err := rows.Scan(
			&i.PostID,
			&i.TopicID,
			&i.UserID,
			&i.Username,
			&i.Title,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTopicByID = `-- name: FindTopicByID :one
SELECT topic_id, user_id, title, created_at FROM Topics WHERE topic_id = $1
`

func (q *Queries) FindTopicByID(ctx context.Context, topicID int64) (Topic, error) {
	row := q.db.QueryRow(ctx, findTopicByID, topicID)
	var i Topic
	err := row.Scan(
		&i.TopicID,
		&i.UserID,
		&i.Title,
		&i.CreatedAt,
	)
	return i, err
}

const findUserByName = `-- name: FindUserByName :one
SELECT user_id, name FROM Users WHERE name = $1
`

// Users Queries
func (q *Queries) FindUserByName(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByName, name)
	var i User
	err := row.Scan(&i.UserID, &i.Name)
	return i, err
}

const listTopics = `-- name: ListTopics :many
SELECT topic_id, user_id, title, created_at FROM Topics ORDER BY title
`

// Topics Queries
func (q *Queries) ListTopics(ctx context.Context) ([]Topic, error) {
	rows, err := q.db.Query(ctx, listTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.TopicID,
			&i.UserID,
			&i.Title,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPost = `-- name: SearchPost :many
SELECT p.post_id, p.topic_id, p.user_id, u.name AS username, p.title, p.description, p.created_at, p.updated_at
FROM Posts p JOIN Users u ON u.user_id = p.user_id WHERE p.topic_id = $1 AND
(p.title ILIKE '%' || $2 ||'%' OR p.description ILIKE '%' || $2 ||'%') ORDER BY p.updated_at DESC
`

type SearchPostParams struct {
	TopicID int64       `json:"topic_id"`
	Column2 pgtype.Text `json:"column_2"`
}

type SearchPostRow struct {
	PostID      int64              `json:"post_id"`
	TopicID     int64              `json:"topic_id"`
	UserID      int64              `json:"user_id"`
	Username    string             `json:"username"`
	Title       string             `json:"title"`
	Description string             `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) SearchPost(ctx context.Context, arg SearchPostParams) ([]SearchPostRow, error) {
	rows, err := q.db.Query(ctx, searchPost, arg.TopicID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchPostRow
	for rows.Next() {
		var i SearchPostRow
		if err := rows.Scan(
			&i.PostID,
			&i.TopicID,
			&i.UserID,
			&i.Username,
			&i.Title,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTopic = `-- name: SearchTopic :many
SELECT topic_id, user_id, title, created_at FROM Topics WHERE title ILIKE '%' || $1 ||'%' ORDER BY title
`

func (q *Queries) SearchTopic(ctx context.Context, dollar_1 pgtype.Text) ([]Topic, error) {
	rows, err := q.db.Query(ctx, searchTopic, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.TopicID,
			&i.UserID,
			&i.Title,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComment = `-- name: UpdateComment :one
UPDATE Comments SET description = $3, updated_at = now() WHERE comment_id = $1 AND post_id = $2 RETURNING comment_id, post_id, user_id, description, created_at, updated_at
`

type UpdateCommentParams struct {
	CommentID   int64  `json:"comment_id"`
	PostID      int64  `json:"post_id"`
	Description string `json:"description"`
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, updateComment, arg.CommentID, arg.PostID, arg.Description)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.PostID,
		&i.UserID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePost = `-- name: UpdatePost :one
UPDATE Posts SET title = $2, description = $3, updated_at = now() WHERE post_id = $1 RETURNING post_id, topic_id, user_id, title, description, created_at, updated_at
`

type UpdatePostParams struct {
	PostID      int64  `json:"post_id"`
	Title       string `json:"title"`
	Description string `json:"description"`
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, updatePost, arg.PostID, arg.Title, arg.Description)
	var i Post
	err := row.Scan(
		&i.PostID,
		&i.TopicID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePostStatus = `-- name: UpdatePostStatus :one
UPDATE Posts SET updated_at = now() WHERE post_id = $1 RETURNING post_id, topic_id, user_id, title, description, created_at, updated_at
`

func (q *Queries) UpdatePostStatus(ctx context.Context, postID int64) (Post, error) {
	row := q.db.QueryRow(ctx, updatePostStatus, postID)
	var i Post
	err := row.Scan(
		&i.PostID,
		&i.TopicID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTopic = `-- name: UpdateTopic :one
UPDATE Topics SET title = $2 WHERE topic_id = $1 RETURNING topic_id, user_id, title, created_at
`

type UpdateTopicParams struct {
	TopicID int64  `json:"topic_id"`
	Title   string `json:"title"`
}

func (q *Queries) UpdateTopic(ctx context.Context, arg UpdateTopicParams) (Topic, error) {
	row := q.db.QueryRow(ctx, updateTopic, arg.TopicID, arg.Title)
	var i Topic
	err := row.Scan(
		&i.TopicID,
		&i.UserID,
		&i.Title,
		&i.CreatedAt,
	)
	return i, err
}
