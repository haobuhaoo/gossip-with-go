// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countVote = `-- name: CountVote :one
SELECT COUNT(*) FILTER (WHERE vote = 1) AS likes, COUNT(*) FILTER (WHERE vote = -1) AS dislikes
FROM Comment_Votes WHERE comment_id = $1
`

type CountVoteRow struct {
	Likes    int64 `json:"likes"`
	Dislikes int64 `json:"dislikes"`
}

func (q *Queries) CountVote(ctx context.Context, commentID int64) (CountVoteRow, error) {
	row := q.db.QueryRow(ctx, countVote, commentID)
	var i CountVoteRow
	err := row.Scan(&i.Likes, &i.Dislikes)
	return i, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO Comments (user_id, post_id, description) VALUES ($1, $2, $3) RETURNING comment_id, post_id, user_id, description, created_at, updated_at
`

type CreateCommentParams struct {
	UserID      int64  `json:"user_id"`
	PostID      int64  `json:"post_id"`
	Description string `json:"description"`
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment, arg.UserID, arg.PostID, arg.Description)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.PostID,
		&i.UserID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO Posts (topic_id, user_id, title, description) VALUES ($1, $2, $3, $4) RETURNING post_id, topic_id, user_id, title, description, created_at, updated_at
`

type CreatePostParams struct {
	TopicID     int64  `json:"topic_id"`
	UserID      int64  `json:"user_id"`
	Title       string `json:"title"`
	Description string `json:"description"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost,
		arg.TopicID,
		arg.UserID,
		arg.Title,
		arg.Description,
	)
	var i Post
	err := row.Scan(
		&i.PostID,
		&i.TopicID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTopic = `-- name: CreateTopic :one
INSERT INTO Topics (user_id, title) VALUES ($1, $2) RETURNING topic_id, user_id, title, created_at
`

type CreateTopicParams struct {
	UserID int64  `json:"user_id"`
	Title  string `json:"title"`
}

func (q *Queries) CreateTopic(ctx context.Context, arg CreateTopicParams) (Topic, error) {
	row := q.db.QueryRow(ctx, createTopic, arg.UserID, arg.Title)
	var i Topic
	err := row.Scan(
		&i.TopicID,
		&i.UserID,
		&i.Title,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO Users (name) VALUES ($1) RETURNING user_id, name
`

func (q *Queries) CreateUser(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, createUser, name)
	var i User
	err := row.Scan(&i.UserID, &i.Name)
	return i, err
}

const deleteComment = `-- name: DeleteComment :execrows
DELETE FROM Comments WHERE comment_id = $1 AND user_id = $2
`

type DeleteCommentParams struct {
	CommentID int64 `json:"comment_id"`
	UserID    int64 `json:"user_id"`
}

func (q *Queries) DeleteComment(ctx context.Context, arg DeleteCommentParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteComment, arg.CommentID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deletePost = `-- name: DeletePost :execrows
DELETE FROM Posts WHERE post_id = $1 AND user_id = $2
`

type DeletePostParams struct {
	PostID int64 `json:"post_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeletePost(ctx context.Context, arg DeletePostParams) (int64, error) {
	result, err := q.db.Exec(ctx, deletePost, arg.PostID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteTopic = `-- name: DeleteTopic :execrows
DELETE FROM Topics WHERE topic_id = $1 AND user_id = $2
`

type DeleteTopicParams struct {
	TopicID int64 `json:"topic_id"`
	UserID  int64 `json:"user_id"`
}

func (q *Queries) DeleteTopic(ctx context.Context, arg DeleteTopicParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteTopic, arg.TopicID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const dislikesComment = `-- name: DislikesComment :one
INSERT INTO Comment_Votes (comment_id, user_id, vote) VALUES ($1, $2, -1)
ON CONFLICT (comment_id, user_id) DO UPDATE SET vote = -1 WHERE Comment_Votes.vote <> -1 RETURNING comment_id, user_id, vote, created_at
`

type DislikesCommentParams struct {
	CommentID int64 `json:"comment_id"`
	UserID    int64 `json:"user_id"`
}

func (q *Queries) DislikesComment(ctx context.Context, arg DislikesCommentParams) (CommentVote, error) {
	row := q.db.QueryRow(ctx, dislikesComment, arg.CommentID, arg.UserID)
	var i CommentVote
	err := row.Scan(
		&i.CommentID,
		&i.UserID,
		&i.Vote,
		&i.CreatedAt,
	)
	return i, err
}

const dislikesPost = `-- name: DislikesPost :one
INSERT INTO Post_Votes (post_id, user_id, vote) VALUES ($1, $2, -1)
ON CONFLICT (post_id, user_id) DO UPDATE SET vote = -1 WHERE Post_Votes.vote <> -1 RETURNING post_id, user_id, vote, created_at
`

type DislikesPostParams struct {
	PostID int64 `json:"post_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DislikesPost(ctx context.Context, arg DislikesPostParams) (PostVote, error) {
	row := q.db.QueryRow(ctx, dislikesPost, arg.PostID, arg.UserID)
	var i PostVote
	err := row.Scan(
		&i.PostID,
		&i.UserID,
		&i.Vote,
		&i.CreatedAt,
	)
	return i, err
}

const findCommentsByPost = `-- name: FindCommentsByPost :many
SELECT c.comment_id, c.user_id, u.name as username, c.post_id, c.description, c.created_at, c.updated_at
FROM Comments c JOIN Users u ON u.user_id = c.user_id WHERE c.post_id = $1 ORDER BY c.updated_at DESC
`

type FindCommentsByPostRow struct {
	CommentID   int64              `json:"comment_id"`
	UserID      int64              `json:"user_id"`
	Username    string             `json:"username"`
	PostID      int64              `json:"post_id"`
	Description string             `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

// Comments Queries
func (q *Queries) FindCommentsByPost(ctx context.Context, postID int64) ([]FindCommentsByPostRow, error) {
	rows, err := q.db.Query(ctx, findCommentsByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindCommentsByPostRow
	for rows.Next() {
		var i FindCommentsByPostRow
		if err := rows.Scan(
			&i.CommentID,
			&i.UserID,
			&i.Username,
			&i.PostID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPostByID = `-- name: FindPostByID :one
SELECT DISTINCT p.post_id, p.topic_id, p.user_id, u.name AS username,
p.title, p.description, p.created_at, p.updated_at,
COUNT(v.vote) FILTER (WHERE v.vote = 1) OVER (PARTITION BY p.post_id) AS likes,
COUNT(v.vote) FILTER (WHERE v.vote = -1) OVER (PARTITION BY p.post_id) AS dislikes,
MAX(uv.vote) OVER (PARTITION BY p.post_id) AS user_vote
FROM Posts p
JOIN Users u ON u.user_id = p.user_id
LEFT JOIN Post_Votes v ON p.post_id = v.post_id
LEFT JOIN Post_Votes uv ON p.post_id = uv.post_id AND uv.user_id = $3
WHERE p.post_id = $1 AND p.topic_id = $2
`

type FindPostByIDParams struct {
	PostID  int64 `json:"post_id"`
	TopicID int64 `json:"topic_id"`
	UserID  int64 `json:"user_id"`
}

type FindPostByIDRow struct {
	PostID      int64              `json:"post_id"`
	TopicID     int64              `json:"topic_id"`
	UserID      int64              `json:"user_id"`
	Username    string             `json:"username"`
	Title       string             `json:"title"`
	Description string             `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Likes       int64              `json:"likes"`
	Dislikes    int64              `json:"dislikes"`
	UserVote    interface{}        `json:"user_vote"`
}

func (q *Queries) FindPostByID(ctx context.Context, arg FindPostByIDParams) (FindPostByIDRow, error) {
	row := q.db.QueryRow(ctx, findPostByID, arg.PostID, arg.TopicID, arg.UserID)
	var i FindPostByIDRow
	err := row.Scan(
		&i.PostID,
		&i.TopicID,
		&i.UserID,
		&i.Username,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Likes,
		&i.Dislikes,
		&i.UserVote,
	)
	return i, err
}

const findPostsByTopic = `-- name: FindPostsByTopic :many
SELECT DISTINCT p.post_id, p.topic_id, p.user_id, u.name AS username,
p.title, p.description, p.created_at, p.updated_at,
COUNT(v.vote) FILTER (WHERE v.vote = 1) OVER (PARTITION BY p.post_id) AS likes,
COUNT(v.vote) FILTER (WHERE v.vote = -1) OVER (PARTITION BY p.post_id) AS dislikes,
MAX(uv.vote) OVER (PARTITION BY p.post_id) AS user_vote
FROM Posts p
JOIN Users u ON u.user_id = p.user_id
LEFT JOIN Post_Votes v ON p.post_id = v.post_id
LEFT JOIN Post_Votes uv ON p.post_id = uv.post_id AND uv.user_id = $2
WHERE p.topic_id = $1
ORDER BY likes DESC, p.updated_at DESC
`

type FindPostsByTopicParams struct {
	TopicID int64 `json:"topic_id"`
	UserID  int64 `json:"user_id"`
}

type FindPostsByTopicRow struct {
	PostID      int64              `json:"post_id"`
	TopicID     int64              `json:"topic_id"`
	UserID      int64              `json:"user_id"`
	Username    string             `json:"username"`
	Title       string             `json:"title"`
	Description string             `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Likes       int64              `json:"likes"`
	Dislikes    int64              `json:"dislikes"`
	UserVote    interface{}        `json:"user_vote"`
}

// Posts Queries
func (q *Queries) FindPostsByTopic(ctx context.Context, arg FindPostsByTopicParams) ([]FindPostsByTopicRow, error) {
	rows, err := q.db.Query(ctx, findPostsByTopic, arg.TopicID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindPostsByTopicRow
	for rows.Next() {
		var i FindPostsByTopicRow
		if err := rows.Scan(
			&i.PostID,
			&i.TopicID,
			&i.UserID,
			&i.Username,
			&i.Title,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Likes,
			&i.Dislikes,
			&i.UserVote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTopicByID = `-- name: FindTopicByID :one
SELECT topic_id, user_id, title, created_at FROM Topics WHERE topic_id = $1
`

func (q *Queries) FindTopicByID(ctx context.Context, topicID int64) (Topic, error) {
	row := q.db.QueryRow(ctx, findTopicByID, topicID)
	var i Topic
	err := row.Scan(
		&i.TopicID,
		&i.UserID,
		&i.Title,
		&i.CreatedAt,
	)
	return i, err
}

const findUserByID = `-- name: FindUserByID :one
SELECT user_id, name FROM Users WHERE user_id = $1
`

func (q *Queries) FindUserByID(ctx context.Context, userID int64) (User, error) {
	row := q.db.QueryRow(ctx, findUserByID, userID)
	var i User
	err := row.Scan(&i.UserID, &i.Name)
	return i, err
}

const findUserByName = `-- name: FindUserByName :one
SELECT user_id, name FROM Users WHERE name = $1
`

// Users Queries
func (q *Queries) FindUserByName(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByName, name)
	var i User
	err := row.Scan(&i.UserID, &i.Name)
	return i, err
}

const likesComment = `-- name: LikesComment :one
INSERT INTO Comment_Votes (comment_id, user_id, vote) VALUES ($1, $2, 1)
ON CONFLICT (comment_id, user_id) DO UPDATE SET vote = 1 WHERE Comment_Votes.vote <> 1 RETURNING comment_id, user_id, vote, created_at
`

type LikesCommentParams struct {
	CommentID int64 `json:"comment_id"`
	UserID    int64 `json:"user_id"`
}

// Comment Votes
func (q *Queries) LikesComment(ctx context.Context, arg LikesCommentParams) (CommentVote, error) {
	row := q.db.QueryRow(ctx, likesComment, arg.CommentID, arg.UserID)
	var i CommentVote
	err := row.Scan(
		&i.CommentID,
		&i.UserID,
		&i.Vote,
		&i.CreatedAt,
	)
	return i, err
}

const likesPost = `-- name: LikesPost :one
INSERT INTO Post_Votes (post_id, user_id, vote) VALUES ($1, $2, 1)
ON CONFLICT (post_id, user_id) DO UPDATE SET vote = 1 WHERE Post_Votes.vote <> 1 RETURNING post_id, user_id, vote, created_at
`

type LikesPostParams struct {
	PostID int64 `json:"post_id"`
	UserID int64 `json:"user_id"`
}

// Post Votes
func (q *Queries) LikesPost(ctx context.Context, arg LikesPostParams) (PostVote, error) {
	row := q.db.QueryRow(ctx, likesPost, arg.PostID, arg.UserID)
	var i PostVote
	err := row.Scan(
		&i.PostID,
		&i.UserID,
		&i.Vote,
		&i.CreatedAt,
	)
	return i, err
}

const listTopics = `-- name: ListTopics :many
SELECT topic_id, user_id, title, created_at FROM Topics ORDER BY title
`

// Topics Queries
func (q *Queries) ListTopics(ctx context.Context) ([]Topic, error) {
	rows, err := q.db.Query(ctx, listTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.TopicID,
			&i.UserID,
			&i.Title,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCommentVote = `-- name: RemoveCommentVote :execrows
DELETE FROM Comment_Votes WHERE comment_id = $1 AND user_id = $2
`

type RemoveCommentVoteParams struct {
	CommentID int64 `json:"comment_id"`
	UserID    int64 `json:"user_id"`
}

func (q *Queries) RemoveCommentVote(ctx context.Context, arg RemoveCommentVoteParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeCommentVote, arg.CommentID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const removePostVote = `-- name: RemovePostVote :execrows
DELETE FROM Post_Votes WHERE post_id = $1 AND user_id = $2
`

type RemovePostVoteParams struct {
	PostID int64 `json:"post_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) RemovePostVote(ctx context.Context, arg RemovePostVoteParams) (int64, error) {
	result, err := q.db.Exec(ctx, removePostVote, arg.PostID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const searchPost = `-- name: SearchPost :many
SELECT DISTINCT p.post_id, p.topic_id, p.user_id, u.name AS username,
p.title, p.description, p.created_at, p.updated_at,
COUNT(v.vote) FILTER (WHERE v.vote = 1) OVER (PARTITION BY p.post_id)AS likes,
COUNT(v.vote) FILTER (WHERE v.vote = -1) OVER (PARTITION BY p.post_id)AS dislikes,
MAX(uv.vote) OVER (PARTITION BY p.post_id)AS user_vote
FROM Posts p
JOIN Users u ON u.user_id = p.user_id
LEFT JOIN Post_Votes v ON p.post_id = v.post_id
LEFT JOIN Post_Votes uv ON p.post_id = uv.post_id AND uv.user_id = $3
WHERE p.topic_id = $1 AND (p.title ILIKE '%' || $2 ||'%' OR p.description ILIKE '%' || $2 ||'%')
ORDER BY likes DESC, p.updated_at DESC
`

type SearchPostParams struct {
	TopicID int64       `json:"topic_id"`
	Column2 pgtype.Text `json:"column_2"`
	UserID  int64       `json:"user_id"`
}

type SearchPostRow struct {
	PostID      int64              `json:"post_id"`
	TopicID     int64              `json:"topic_id"`
	UserID      int64              `json:"user_id"`
	Username    string             `json:"username"`
	Title       string             `json:"title"`
	Description string             `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Likes       int64              `json:"likes"`
	Dislikes    int64              `json:"dislikes"`
	UserVote    interface{}        `json:"user_vote"`
}

func (q *Queries) SearchPost(ctx context.Context, arg SearchPostParams) ([]SearchPostRow, error) {
	rows, err := q.db.Query(ctx, searchPost, arg.TopicID, arg.Column2, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchPostRow
	for rows.Next() {
		var i SearchPostRow
		if err := rows.Scan(
			&i.PostID,
			&i.TopicID,
			&i.UserID,
			&i.Username,
			&i.Title,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Likes,
			&i.Dislikes,
			&i.UserVote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTopic = `-- name: SearchTopic :many
SELECT topic_id, user_id, title, created_at FROM Topics WHERE title ILIKE '%' || $1 ||'%' ORDER BY title
`

func (q *Queries) SearchTopic(ctx context.Context, dollar_1 pgtype.Text) ([]Topic, error) {
	rows, err := q.db.Query(ctx, searchTopic, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.TopicID,
			&i.UserID,
			&i.Title,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComment = `-- name: UpdateComment :one
UPDATE Comments SET description = $4, updated_at = now()
WHERE comment_id = $1 AND post_id = $2 AND user_id = $3 RETURNING comment_id, post_id, user_id, description, created_at, updated_at
`

type UpdateCommentParams struct {
	CommentID   int64  `json:"comment_id"`
	PostID      int64  `json:"post_id"`
	UserID      int64  `json:"user_id"`
	Description string `json:"description"`
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, updateComment,
		arg.CommentID,
		arg.PostID,
		arg.UserID,
		arg.Description,
	)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.PostID,
		&i.UserID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePost = `-- name: UpdatePost :one
UPDATE Posts SET title = $3, description = $4, updated_at = now() WHERE post_id = $1 AND user_id = $2 RETURNING post_id, topic_id, user_id, title, description, created_at, updated_at
`

type UpdatePostParams struct {
	PostID      int64  `json:"post_id"`
	UserID      int64  `json:"user_id"`
	Title       string `json:"title"`
	Description string `json:"description"`
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, updatePost,
		arg.PostID,
		arg.UserID,
		arg.Title,
		arg.Description,
	)
	var i Post
	err := row.Scan(
		&i.PostID,
		&i.TopicID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePostStatus = `-- name: UpdatePostStatus :one
UPDATE Posts SET updated_at = now() WHERE post_id = $1 AND user_id = $2 RETURNING post_id, topic_id, user_id, title, description, created_at, updated_at
`

type UpdatePostStatusParams struct {
	PostID int64 `json:"post_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) UpdatePostStatus(ctx context.Context, arg UpdatePostStatusParams) (Post, error) {
	row := q.db.QueryRow(ctx, updatePostStatus, arg.PostID, arg.UserID)
	var i Post
	err := row.Scan(
		&i.PostID,
		&i.TopicID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTopic = `-- name: UpdateTopic :one
UPDATE Topics SET title = $3 WHERE topic_id = $1 AND user_id = $2 RETURNING topic_id, user_id, title, created_at
`

type UpdateTopicParams struct {
	TopicID int64  `json:"topic_id"`
	UserID  int64  `json:"user_id"`
	Title   string `json:"title"`
}

func (q *Queries) UpdateTopic(ctx context.Context, arg UpdateTopicParams) (Topic, error) {
	row := q.db.QueryRow(ctx, updateTopic, arg.TopicID, arg.UserID, arg.Title)
	var i Topic
	err := row.Scan(
		&i.TopicID,
		&i.UserID,
		&i.Title,
		&i.CreatedAt,
	)
	return i, err
}
